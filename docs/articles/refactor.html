<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>refactor. refactor</title><!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <div class="container">
      <header><div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">refactor</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"></ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>refactor</h1>
                        <h4 class="author">Lorenz Walthert and Jon Calder</h4>
            
            <h4 class="date">2017-02-08</h4>
          </div>

    
    
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Working with factors in R can be frustrating. As described well by <a href="http://www.win-vector.com/blog/2014/09/factors-are-not-first-class-citizens-in-r/">John Mount</a>, factors are not first-class citizens in R. Even the most basic code often behaves in an unexpected manner and without any warning. Let&rsquo;s start off with a simple example - creating two factor vectors and combining them together - that illustrates some of the issues:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lower &lt;-<span class="st"> </span><span class="kw">factor</span>(letters[<span class="dv">1</span>:<span class="dv">3</span>], <span class="dt">levels =</span> letters[<span class="dv">2</span>:<span class="dv">4</span>])
upper &lt;-<span class="st"> </span><span class="kw">factor</span>(LETTERS[<span class="dv">1</span>:<span class="dv">5</span>], <span class="dt">levels =</span> LETTERS[<span class="dv">1</span>:<span class="dv">4</span>])
(combined &lt;-<span class="st"> </span><span class="kw">c</span>(lower, upper))</code></pre></div>
<pre><code>## [1] NA  1  2  1  2  3  4 NA</code></pre>
<p>One can note the following issues:</p>
<ul><li><code>factor()</code> does not yield an error when <code>NA</code>s are created silently, neither when levels do not match x nor when too few levels are specified.</li>
<li>When <code>c()</code> is used to combine the two, the levels of the two elements (which are just attributes to integer vectors) are not conveyed, R simply combines the underlying integers from each vector.</li>
<li>This not only changes the data representation but fundamentally changes the data values and makes it impossible to restore the information. e.g.&nbsp;1 now represents the first level of both <code>lower</code> and <code>upper</code>, so a 1 in the combined vector could be either <code>b</code> or an <code>A</code> from one of the original vectors.</li>
</ul><p>The goal of the <code>refactor</code> package is to make working with factors more natural and fun by providing</p>
<ul><li>the wrapper <code>cfactor</code> for <code>factor</code> to enhance control at the point of factor creation.</li>
<li>a function <code>index_cfactor</code> to decode numerical data into (ordered) factors given the encoding.</li>
<li>S3 generics for existing R base classes (mainly <code>ordered</code> and <code>factor</code>) where current methods are not tailored for categorical data.</li>
</ul></div>
<div id="cfactor" class="section level2">
<h2><code>cfactor</code></h2>
<p><code>cfactor</code> has been defined to give warnings in cases when empty factors are created from strings or when existing strings are not preserved. Essentially, it is a wrapper for <code>factor()</code>, and the &lsquo;c&rsquo; stands for enhanced control. It also has improved level order detection based on numerical values within strings that is superior to the way <code>factor</code> assesses this order in certain cases.</p>
<div id="unmatched-factors" class="section level3">
<h3>unmatched factors</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(refactor)

string &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>)
<span class="kw">cfactor</span>(string, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>))</code></pre></div>
<pre><code>## Warning: the following levels were empty: 
##  d</code></pre>
<pre><code>## Warning: the following levels were removed: 
##  a</code></pre>
<pre><code>## [1] &lt;NA&gt; b    c   
## Levels: b c d</code></pre>
</div>
<div id="detect-levels" class="section level3">
<h3>detect levels</h3>
<p>The default behavior of <code>factor</code> (if levels are not explicitly supplied), is to first convert <code>x</code> to character, and then to take the unique values and sort the characters (<code>sort(unique(as.character(x)))</code>). This approach is fine if the string ordering was the same as ordering the numbers within the string, but in general this is not the case, as the following examples will illustrate:</p>
<p><br><strong>A &ldquo;clean&rdquo; example</strong></p>
<p>With all numbers having the same number of digits, <code>factor</code> can detect the order correctly.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">easy_to_dectect &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"EUR 11 - EUR 20"</span>, <span class="st">"EUR 1 - EUR 10"</span>, <span class="st">"EUR 21 - EUR 22"</span>)
<span class="kw">factor</span>(easy_to_dectect, <span class="dt">ordered =</span> <span class="ot">TRUE</span>) <span class="co"># correctly detects level</span></code></pre></div>
<pre><code>## [1] EUR 11 - EUR 20 EUR 1 - EUR 10  EUR 21 - EUR 22
## Levels: EUR 1 - EUR 10 &lt; EUR 11 - EUR 20 &lt; EUR 21 - EUR 22</code></pre>
<p><br><strong>A more &ldquo;dirty&rdquo; example</strong></p>
<p>However, in the general case, where number of digits might be destinct, this does not work anymore. The category &ldquo;EUR 100 - 101&rdquo; comes second, but it should be last.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hard_to_dectect &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"EUR 21 - EUR 22"</span>, <span class="st">"EUR 100 - 101"</span>, 
                     <span class="st">"EUR 1 - EUR 10"</span>, <span class="st">"EUR 11 - EUR 20"</span>)

<span class="kw">factor</span>(hard_to_dectect, <span class="dt">ordered =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] EUR 21 - EUR 22 EUR 100 - 101   EUR 1 - EUR 10  EUR 11 - EUR 20
## 4 Levels: EUR 1 - EUR 10 &lt; EUR 100 - 101 &lt; ... &lt; EUR 21 - EUR 22</code></pre>
<p><code>cfactor</code> detects levels using regular expressions. Concretely, it extracts the substrings preceding <code>sep</code>, removes everything except digits and the decimal point in <code>x</code> and orders the remaining numbers to find the order of the levels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cfactor</span>(hard_to_dectect, <span class="dt">ordered =</span> <span class="ot">TRUE</span>, <span class="dt">sep =</span> <span class="st">"-"</span>)</code></pre></div>
<pre><code>## [1] EUR 21 - EUR 22 EUR 100 - 101   EUR 1 - EUR 10  EUR 11 - EUR 20
## 4 Levels: EUR 1 - EUR 10 &lt; EUR 11 - EUR 20 &lt; ... &lt; EUR 100 - 101</code></pre>
<p>This detection algorithm can be turned off and the default ordering of <code>factor</code> can be applied by setting the <code>sep</code> argument to <code>NULL</code>. Also, in the absence of any numbers, the default ordering of <code>factor</code> is applied.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(
  <span class="kw">cfactor</span>(hard_to_dectect, <span class="dt">ordered =</span> <span class="ot">TRUE</span>, <span class="dt">sep =</span> <span class="ot">NULL</span>),
   <span class="kw">factor</span>(hard_to_dectect, <span class="dt">ordered =</span> <span class="ot">TRUE</span>)
)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="intersection-of-underlying-values-and-labels" class="section level3">
<h3>Intersection of underlying values and labels</h3>
<p>When creating a <code>factor</code> you sometimes want to label that data, that is, assign a label to each value supplied in <code>x</code>. A situation to avoid is using labels that are identical to its underlaying value for some but not all levels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cfactor</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>), <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"letter b"</span>, <span class="st">"b"</span>))</code></pre></div>
<pre><code>## Warning in cfactor(x = c("a", "b", "c"), levels = c("a", "b", "c"), labels = c("a", : Some values now used for the labels existed in the data vector 'x' already: 
##   'b' is now represented with 'letter b', 'b' now represents 'c' 
##   'a' still represents 'a'</code></pre>
<pre><code>## [1] a        letter b b       
## Levels: a letter b b</code></pre>
<p>The outcome of this is kind of messy. Whereas <code>factor</code> lets you do that without returing any warning, <code>cfactor</code> will issue a such to inform about the intersection.<br>
In adition, a second warning that indicates that <code>a</code> is choosen as a representation of <code>a</code> itself is issued. In a context where data are given labels distinct from their values, which is the whole point of labeling, this in many cases proabably not what the programmer wanted to see happening.</p>
</div>
</div>
<div id="index_cfactor" class="section level2">
<h2><code>index_cfactor</code></h2>
<p>If data is encoded, the <code>labels</code> argument of <code>factor()</code> can be used to label the data, which is a common data pre-processing step. This works the same as with <code>cfactor()</code>. Here, we want to give an example where the relationship b eteween the encoding and the label is stored in a <code>data.frame</code>, e.g.&nbsp;after it was imported from a spread sheet.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">size =</span> <span class="dv">20</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
index &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">encoding =</span> <span class="dv">1</span>:<span class="dv">10</span>,
                    <span class="dt">label =</span> letters[<span class="dv">1</span>:<span class="dv">10</span>])

<span class="kw">cfactor</span>(data, <span class="dt">levels =</span> index$encoding, <span class="dt">labels =</span> index$label)</code></pre></div>
<pre><code>## Warning: the following levels were empty: 
##  2
## 5</code></pre>
<pre><code>##  [1] g f g f i h i a i j f d h f g i f c j i
## Levels: a b c d e f g h i j</code></pre>
<p><br>
In a real-world situation, it is likely that a lot of variables have to be decoded. <code>index_cfactor</code> was created to assist with this task. First, we need some sample data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">var1 =</span> <span class="kw">sample</span>(<span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">size =</span> <span class="dv">20</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>),
                  <span class="dt">var2 =</span> <span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">20</span>),
                  <span class="dt">var3 =</span> <span class="kw">sample</span>(<span class="dv">20</span>),
                  <span class="dt">var4 =</span> <span class="dv">2</span>, 
                  <span class="dt">var5 =</span> <span class="kw">sample</span>(<span class="kw">row.names</span>(USArrests), <span class="dt">size =</span> <span class="dv">20</span>),
                  <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
<span class="kw">head</span>(data)</code></pre></div>
<pre><code>##   var1 var2 var3 var4         var5
## 1    3    1    1    2      Wyoming
## 2    5    2   12    2         Ohio
## 3    8    1    5    2       Hawaii
## 4    2    2   16    2      Indiana
## 5    2    1   14    2 North Dakota
## 6    2    2   11    2 Rhode Island</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">index &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">var =</span> <span class="kw">rep</span>(<span class="kw">paste0</span>(<span class="st">"var"</span>, <span class="dv">1</span>:<span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">2</span>, <span class="dv">20</span>)),
                    <span class="dt">encoding =</span> <span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="dv">20</span>),
                    <span class="dt">label =</span> <span class="kw">c</span>(letters[<span class="dv">1</span>:<span class="dv">10</span>], <span class="kw">c</span>(<span class="st">"male"</span>, <span class="st">"female"</span>), LETTERS[<span class="dv">1</span>:<span class="dv">20</span>]))
<span class="kw">head</span>(index)</code></pre></div>
<pre><code>##    var encoding label
## 1 var1        1     a
## 2 var1        2     b
## 3 var1        3     c
## 4 var1        4     d
## 5 var1        5     e
## 6 var1        6     f</code></pre>
<p>Now we use <code>index_cfactor</code> to decode the <code>data.frame</code>. Note that <code>var4</code> and <code>var5</code> are left as is, since no variable encoding for them is defined in <code>index</code>. Using the <code>...</code> argument of <code>index_cfactor</code>, we can pass additional arguments to <code>cfactor</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">final &lt;-<span class="st"> </span><span class="kw">head</span>(<span class="kw">index_cfactor</span>(<span class="dt">data =</span> data, <span class="dt">index =</span> index, <span class="dt">variable =</span> <span class="st">"var"</span>, 
                            <span class="dt">ordered =</span> <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)))</code></pre></div>
<pre><code>## Warning: the following levels were empty: 
##  4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(final)</code></pre></div>
<pre><code>##   var1   var2 var3 var4         var5
## 1    c   male    A    2      Wyoming
## 2    e female    L    2         Ohio
## 3    h   male    E    2       Hawaii
## 4    b female    P    2      Indiana
## 5    b   male    N    2 North Dakota
## 6    b female    K    2 Rhode Island</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sapply</span>(final, class)</code></pre></div>
<pre><code>## $var1
## [1] "ordered" "factor" 
## 
## $var2
## [1] "ordered" "factor" 
## 
## $var3
## [1] "factor"
## 
## $var4
## [1] "numeric"
## 
## $var5
## [1] "character"</code></pre>
<p><code>index_cfactor</code> converts all columns in <code>data</code> that have a match in <code>index</code> to factors with the respective encoding using <code>cfactor</code>. Further arguments are <code>variable</code>, <code>label</code> and <code>encoding</code> referring to the column names in index that contain the respective information.</p>
<p><strong>Other example strings</strong></p>
<pre><code>## [1] "1 to 4" "5 to 6"</code></pre>
<pre><code>## [1] "1 to 4" "4 to 6"</code></pre>
<pre><code>## [1] "from 1,000 to 2,000" "from 2000 to 4,000"</code></pre>
<pre><code>## [1] "4.0 / 4.1" "4.2 / 4.3"</code></pre>
<pre><code>## [1] "one minute"    "three minutes" "1 hour"</code></pre>
</div>
<div id="tailored-methods-for-categorical-data" class="section level2">
<h2>tailored methods for categorical data</h2>
<p>Instead of defining completely new functions, we decided to provide some S3 generics to extend the functionality of existing R functions and tailor them so they are better suited for categorical data. Also, a more extensive warning and error behavior than for their base R counterparts is implemented.</p>
<div id="cut" class="section level3">
<h3><code>cut</code></h3>
<p>Applying cut can result in categorical data, for example if integers are binned or if ordered factor levels are summarized into larger categories.</p>
<div id="a-cut-method-for-integers" class="section level4">
<h4>a <code>cut</code> method for integers</h4>
<p><code>cut.default</code> provides rather inappropriate labels for integer values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">random &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">100</span>)
<span class="kw">cut.default</span>(random, <span class="dt">breaks =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dt">by =</span> <span class="dv">10</span>))[<span class="dv">1</span>:<span class="dv">10</span>]</code></pre></div>
<pre><code>##  [1] (10,20]  (40,50]  (20,30]  (60,70]  (10,20]  (90,100] (30,40] 
##  [8] (30,40]  (80,90]  (70,80] 
## 10 Levels: (0,10] (10,20] (20,30] (30,40] (40,50] (50,60] ... (90,100]</code></pre>
<p><code>refactor</code> extends the S3 method <code>cut</code> with <code>cut.integer</code> to provide more natural labels for this data type.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cut</span>(random, <span class="dt">breaks =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dt">by =</span> <span class="dv">10</span>))[<span class="dv">1</span>:<span class="dv">10</span>]</code></pre></div>
<pre><code>##  [1] 11-20  41-50  21-30  61-70  11-20  91-100 31-40  31-40  81-90  71-80 
## Levels: 0-10 11-20 21-30 31-40 41-50 51-60 61-70 71-80 81-90 91-100</code></pre>
<p>The remainder of the section will outline and describe how <code>cut.integer</code> deviates from the default <code>cut</code> method.<br><br><br> Creating missing values will yield a warning.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cut</span>(<span class="kw">sample</span>(<span class="dv">10</span>), <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">5</span>))</code></pre></div>
<pre><code>## Warning in cut.integer(sample(10), breaks = c(0, 3, 5)): 5 missing values
## generated</code></pre>
<pre><code>##  [1] 0-3  &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 4-5  4-5  0-3  &lt;NA&gt; 0-3  &lt;NA&gt;
## Levels: 0-3 4-5</code></pre>
<p>It is possible to define bins with width 1. This will generate a label with just the value of the integer containted (e.g.&nbsp;2 instead of 2-2) and issue a warning.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cut</span>(<span class="kw">sample</span>(<span class="dv">10</span>), <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>))</code></pre></div>
<pre><code>##  [1] 5-6 1-4 1-4 7-8 7-8 1-4 9   5-6 1-4 10 
## Levels: 1-4 5-6 7-8 9 10</code></pre>
<p>Unordered breaks will be ordered before proceeding and a warning will be issued.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cut</span>(<span class="kw">sample</span>(<span class="dv">10</span>), <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">3</span>))</code></pre></div>
<pre><code>## Warning in cut.integer(sample(10), breaks = c(10, 0, 3)): breaks were
## unsorted and are now sorted in the following order: 0 3 10</code></pre>
<pre><code>##  [1] 0-3  4-10 0-3  4-10 4-10 4-10 4-10 0-3  4-10 4-10
## Levels: 0-3 4-10</code></pre>
<p>Decimal values for <code>breaks</code> will be rounded to integers and a warning will be issued.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cut</span>(<span class="kw">sample</span>(<span class="dv">10</span>), <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">2.6</span>, <span class="fl">5.1</span>, <span class="dv">10</span>))</code></pre></div>
<pre><code>## Warning in cut.integer(sample(10), breaks = c(1, 2.6, 5.1, 10)): When coerced to integers, the following breaks were truncated (rounded down): 
##   2.6 to 2  
##   5.1 to 5  
## </code></pre>
<pre><code>##  [1] 1-2  6-10 1-2  6-10 6-10 6-10 3-5  3-5  6-10 3-5 
## Levels: 1-2 3-5 6-10</code></pre>
</div>
<div id="a-cut-method-for-ordered-factors" class="section level4">
<h4>a <code>cut</code> method for ordered factors</h4>
<p>This method allows one to combine the levels of a factor into fewer categories given some break points:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">some_letters &lt;-<span class="st"> </span><span class="kw">cfactor</span>(letters, <span class="dt">ordered =</span> <span class="ot">TRUE</span>)
<span class="kw">head</span>(<span class="kw">cut</span>(some_letters, <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"q"</span>, <span class="st">"z"</span>), 
         <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">"beginning of the alphabet"</span>, <span class="st">"the rest of the alphabeth"</span>), 
         <span class="dt">right =</span> <span class="ot">TRUE</span>, <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>))</code></pre></div>
<pre><code>## [1] beginning of the alphabet beginning of the alphabet
## [3] beginning of the alphabet beginning of the alphabet
## [5] beginning of the alphabet beginning of the alphabet
## Levels: beginning of the alphabet &lt; the rest of the alphabeth</code></pre>
</div>
</div>
</div>
<div id="cc" class="section level2">
<h2>cc</h2>
<p>The purpose of <code>cc</code> is to combine elements into a vector, just as base <code>c</code> does. They only differ with regard to factor treatment, for which <code>c</code> most likely does not return what might be expected.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="kw">cfactor</span>(<span class="st">"a"</span>), <span class="kw">cfactor</span>(<span class="st">"b"</span>))</code></pre></div>
<pre><code>## [1] 1 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cc</span>(<span class="kw">cfactor</span>(<span class="st">"a"</span>), <span class="kw">cfactor</span>(<span class="st">"b"</span>))</code></pre></div>
<pre><code>## Warning: ordering and levels not preserved since levels not identical</code></pre>
<pre><code>## [1] a b
## Levels: a b</code></pre>
<p><code>cc</code> can also deal with ordered factors. It is quite verbose in the sense that if the levels and/or the order of the levels do not match exactly, it will issue warnings.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a_b &lt;-<span class="st"> </span><span class="kw">cfactor</span>(<span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>), <span class="dt">ordered =</span> T)
b_d &lt;-<span class="st"> </span><span class="kw">cfactor</span>(<span class="kw">c</span>(<span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>), <span class="dt">ordered =</span> T)
<span class="kw">cc</span>(a_b, b_d)</code></pre></div>
<pre><code>## Warning: ordering and levels not preserved since levels not identical</code></pre>
<pre><code>## [1] a b b c d
## Levels: a b c d</code></pre>
</div>
<div id="append" class="section level2">
<h2>append</h2>
</div>
  </div>

  <div class="col-md-3 hidden-xs">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked"><li><a href="#introduction">Introduction</a></li>
      <li><a href="#cfactor"><code>cfactor</code></a></li>
      <li><a href="#index_cfactor"><code>index_cfactor</code></a></li>
      <li><a href="#tailored-methods-for-categorical-data">tailored methods for categorical data</a></li>
      <li><a href="#cc">cc</a></li>
      <li><a href="#append">append</a></li>
      </ul></div>
      </div>

</div>


      <footer><p>Built by <a href="http://hadley.github.io/pkgdown/">pkgdown</a>. Styled with <a href="http://getbootstrap.com">Bootstrap 3</a>.</p>
      </footer></div>

  </body></html>
