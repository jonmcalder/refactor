---
title: "refactor"
author: "Lorenz Walthert and Jon Calder"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{refactor}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

Working with factors in R can be frustrating. As described well by [John Monut](http://www.win-vector.com/blog/2014/09/factors-are-not-first-class-citizens-in-r/), factors are not first-class citizens in R. Even most basic code does often behave in an unexpeced manner and without any warning. Let's start off with a simple example that illustrates some of the issues: Creating two factor vectors and combining them together:

```{r}
lower <- factor(letters[1:3], levels = letters[2:4])
upper <- factor(LETTERS[1:5], levels = LETTERS[1:4])
(combined <- c(lower, upper))
```


One can note the following issues:

* `factor()` does not yield an error when `NA`s are created silently, neither when levels does not match x nor when too few levels are specified. 
* When `c()` is used to combine the two, the levels of the two elements (which are just attributes to integer vectors) are not conveyed, R puts together the underlying integers.
* This is not only changing the data representation but also make it impossible to restore the information, i.e. 1 represents now the first level of both `lower` and `upper`, so it can either be `b` or `A` which does not really make sense.

The goal of the `refactor` package is to make working with factors more natural and fun by

* providing a wrapper for `factor` to enhance control at the point of factor creation
* providing S3 generics for existing R base classes (mainly `ordered` and `factor`) where current methods are not tailored for categorical data.

## `cfactor`
`cfactor` has been defined to give warnings in cases when empty factors are created from strings or when existing strings are not preserved. Essentially, it is a wrapper for `factor()`, and the 'c' stands for enhanced control. It also has an improved level order detection based on numerical values within strings that is superior to the way `factor` assesses this order in certain cases.

### unmatched factors
```{r}
string <- c("a", "b", "c")
library(refactor)
# with refactor::cfactor warnings are issued to communicate fact that levels were referenced that do not appear in the data and vice versa
cfactor(string, levels = c("b", "c", "d"))
```

### detect levels
The default behavior of `factor` is (if levels is not explicitly supplied) to first convert `x` to character, take the unique values and sort the characters (`sort(unique(as.character(x)))`), which is fine if the string ordering was the same as ordering the numbers within the string, but in general that is not the case.

\
**A "clean" example**

With all numbers having the same number of digits, `factor` can detect the order correctly.
```{r}
easy_to_dectect <- c("EUR 11 - EUR 20", "EUR 1 - EUR 10", "EUR 21 - EUR 22")
factor(easy_to_dectect, ordered = T) # correctly detects level
```

**A more "dirty" example**

However, in the general case, where number of digits might be destinct, this does not work anymore. The category "EUR 100 - 101" comes second, but it should be last.
```{r}
hard_to_dectect <- c("EUR 21 - EUR 22", "EUR 100 - 101", "EUR 1 - EUR 10", "EUR 11 - EUR 20")
factor(hard_to_dectect, ordered = T)
```

`cfactor` detects levels using regular expressions. Concretely, it extracts the substrings preceding the `sep`, removes everything except digits and the decimal point in `x` and orders the remaining numbers to find the order of the levels.
```{r}
cfactor(hard_to_dectect, ordered = T, sep = "-")
```

This detection algorithm can be turned off and the default ordering of factor can be applied by setting the `sep` argument to `NULL`.

```{r}
identical(
  cfactor(hard_to_dectect, ordered = T, sep = NULL),
   factor(hard_to_dectect, ordered = T)
)
```

\
**Other example strings**
```{r, echo = F, include = T}
c("1 to 4", "5 to 6") # properly separated
c("1 to 4", "4 to 6") # not properly separated
c("from 1,000 to 2,000", "from 2000 to 4,000") # comma separated and 'from' and 'to'
c("4.0 / 4.1", "4.2 / 4.3") # point and slash separator
c("one minute", "three minutes", "1 hour")
```

## tailored methods for categorical data
Instead of defining completely new functions, we decided to provide some S3 generics to extend the functionality of existing R functions and tailor them so they are better suited for categorical data. Also, a more extensive warning and error behavior than for their base R counterparts is implemented. 

### `cut`
Applying cut can result in categorical data, for example if integers are binned or if ordered factor levels are summarized into larger categories.

#### a `cut` method for integers
`cut.default` provides kind of inappropriate labels for integer values.
```{r}
random <- sample(100)
cut.default(random, breaks = seq(0, 100, by = 10))[1:10]
```

Hence, we defined `cut.integer` to provide more natural labels for this data type.
```{r}
cut(random, breaks = seq(0, 100, by = 10))[1:10]
```
\
The remainder of the section describes how the method deviates from the default method. \
\
Creating missing values will yield a warning.

```{r}
cut(sample(10), breaks = c(0, 3, 5))
```

It is possible to define bins with width 1. This will generate a label with just the value of the integer containted (e.g. 2 instead of 2-2) and issue a warning.
```{r}
cut(sample(10), breaks = c(1, 4, 6, 8, 9, 10))
```

Unordered breaks will be ordered before proceeding and a warning will be issued.
```{r}
cut(sample(10), breaks = c(10, 0, 3))
```

Decimal values for `breaks` will be rounded to integers and a warning will be issued.
```{r}
cut(sample(10), breaks = c(1, 2.6, 5.1, 10))
```


#### a `cut` method for ordered factors
This method should allow to summarize levels of factors into fewer categories given some break points
```{r}
library(refactor)
timeX <- c("very low", "rather low", "low", "medium", "upper medium", "high")
time <- factor(timeX, levels = unique(timeX), ordered = T)

cut(time, breaks = c("low", "medium", "high"))
```
